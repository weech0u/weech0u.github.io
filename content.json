{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"前端杂谈","text":"Recoder: Wee Chou z-index仅同级Element有效,父子关系只需修改子元素 npm init –yes 生成package.js 且全部选yes选项 **Element.closest()** 方法用来获取：匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。 很重要!!!!在事件委托上很常用 getBoundingClientRect() 获取坐标， 当元素没有left top值时，通过获取坐标来获取位置参数。 很重要！！！！ element.insertAdjacentHTML(position, text) 回流必将引起重绘, 而重绘不一定会引起回流(回流: 改变元素的布局或尺寸…;重绘: 仅改变元素的外观,不会影响布局) 基线总是与行内高度最高的元素一致的 边缘折叠,两个边距中较小的边距被较大的边距所取代 负页边距确实会对垂直格式产生影响，并影响页边距的折叠方式 vertical-align 改变基线的位置 display: grid; 网格布局 很好用 CSS中脱离文档流，bai也就是将元素从普通的布局排版中拿走，其他盒zhi子在定位的时候，会当做脱dao离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。 这个用于视口的meta标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。 多列布局: column-width: 12em; column-width: 4(固定列数,宽度可变) 善于利用calc设定尺寸 -&gt; 例如 calc(50% - 10px) 不能从dispaly:none 开始过渡, 因为还没开始”绘制” 递归 {需要有个结尾} like return 0; 使用原型是为了共享属性和方法 所有引用类型都继承了Object","link":"/2020/08/06/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/"},{"title":"Flask入门（一）---- models","text":"flask1.1python3.7 Flask-SQLalchemy flask的ORM模型使用ORM模型的原因当项目越来越大时,会出现很多问题 如果原生SQL较多 重复使用率低 如果你的数据库发生改变 所有的原生SQL就都要修改 写原生SQL的时候 会有安全隐患 ORM：中文件关系对象的映射 使用ORM去操作数据库的时候 不会再去写原生的SQL了 通过把表映射成 类 字段为你的属性 ORM在执行的时候 也会最终转换为 SQL语句 去操作数据库 易用性 使用ORM可以减少重复SQL的概率 写出来的模型也更加的直观清晰 可移植性 ORM支持很多不同的数据库 安装sudo pop3 install flask-sqlalchemy 一、执行原生SQL 创建数据库create datebase if not exists 库名 character set utf8 安装pymysqlsudo pip3 install pymysql 配置数据库SQLALCHEMY_DATABASE_URI = ‘mysql+pymysql://用户名:密码@主机:端口号/库名’ 实例（从对象中读取配置） 1234567891011121314151617`config.py`class Config(object): '''项目的应用配置类''' DEBUG = True # SQLALCHEMY_DATABASE_URI = \"mysql://root:1234@192.168.31.180:3306/dy\" SQLALCHEMY_TRACK_MODIFICATIONS = False SECRET_KEY = \"DylqFbqxp5ArVPmzd1D/DuhSIszWjtzTxL4LUktID7mvsb6s75ENhRTbZUBikRqV/vPPmUrF4yvuEruzs/K+/A==\" SQLALCHEMY_COMMIT_ON_TEARDOWN = True# 产品线上使用：class Config_Project(Config): DEBUG = False SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/dyinfo?charset=UTF8MB4\"# 线下环境使用class Config_Devlopement(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:89974037zxc@localhost:3306/HelloFlask?charset=UTF8MB4\"config_dict = {'product': Config_Project, 'develop': Config_Devlopement} 123`manage.py`app = Flask(__name__)app.config.from_object(config_dict['develop']) 当前字段类型 类型名 说明 integer 整形 SmallInteger 小整形 BigInteger 长整型 Float 浮点型 String varchar类型 Text 长文本 Boolean tingint Date 日期 datetime.date Time 时间 datetime.time DateTime 时间和日期 datetime.datetime 约束条件 选项 选项说明 primary_key 主键 默认False index 常规 默认 False Unique 唯一 默认 False nullable 是否为null 默认True default 默认值 注意其中的default默认值 并不是更改表结构的默认值 而是在插入数据的时候 如果不插入数据 则插入默认值 实例配置1234567from flask import Flaskfrom flask_script import Managerfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# app中间配置在上个代码块有写db = SQLAlchemy(app)manager = Manager(app) 创建模型12345class User(db.Model): id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') 数据的添加修改删除123456789101112131415161718# 创建蓝图，目的是把一个应用分解成一个蓝图的集合MainView = Blueprint('bp',__name__)PetView = Blueprint('pet',__name__)@MainView.route('/createdb')def create_table(): db.drop_all() # 删除与当前模型类同名的表 db.create_all() # 创建当前模型类的表 return '表创建成功'@MainView.route('/adduser/&lt;string:name&gt;')def adduser(name): user = User() user.username = name user.save() return f'添加成功username={name}' 目录结构树123456789101112131415161718192021222324project/ App/ __init__.py static/ js/ img/ upload/ css/ templates/ common/ ... forms/ __init__.py ... models/ __init__.py views/ __init.py__.py ... settings.py email.py extensions.py manager.py migrations/ 三、数据的操作创建模型类12345678910class User(Base,db.Model): __tablename__ = 'user' #给表起名 id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') def __init__(self,username='',age=0,icon='default.jpg'): self.username = username self.age = age self.icon = icon 添加 add add_all添加一条123456@main.route('/add/')def add(): u = User(username='张三',age=18) db.session.add(u) db.session.commit() return '数据添加一条成功' 添加多条1234567@main.route('/add_all/')def add_all(): u1 = User(username='李四',age=20) u2 = User(username='王五',age=22) db.session.add_all([u1,u2]) db.session.commit() return '添加多条' 自定义增删改查的基础类1234567891011121314151617181920212223class Base: # 定义一个添加一条数据的方法 def save(self): try: db.session.add(self) db.session.commit() except: db.session.rollback() # 定义添加多条数据的方法 @staticmethod def save_all(*args): try: db.session.add_all(args) db.session.commit() except: db.session.rollback() # 自定义删除方法 def delete(self): try: db.session.delete(self) db.session.commit() except: db.session.rollback() 四、数据库操作查询集查询数据的集合 分类 原始查询集 类名.query得到的结果就为原始查询集 数据查询集加上各种的过滤器的方法 最终返回的结果 为数据查询集 都是用数据查询集 过滤器all查询所有 以列表形式返回 不支持连贯操作类名.query.all() 12345@main.route('/all/')def all(): data = User.query.all() print(data) return xxx filter()过滤 返回的是sql语句 需要.all/.first一下 类名.query.filter([类名.属性名 条件操作符 值]) 默认返回所有，支持连贯操作 123# data = User.query.filter() #返回所有# data = User.query.filter(User.age&gt;20) #查询年龄大于20的数据data = User.query.filter(User.age&gt;20,User.age&lt;40) #查询年龄大于20的数据 and 小于40 filter_by只支持参数为关键字参数（）123# data = User.query.filter_by(id=2)# data = User.query.filter_by(id&gt;2) #错误写法data = User.query.filter_by(id=2,age=27) offset和limit组合使用类似分页 12data = User.query.offset(2).limit(2)# limit 2,2 order_by()排序12# data = User.query.order_by(User.age) #升序data = User.query.order_by(-User.age) #降序 get获取id对应的数据查询成功返回对象 查询失败 返回None 1data = User.query.get(2) 过滤条件1234# contains包含data = User.query.filter(User.username.contains('7'))# like模糊查询data = User.query.filter(User.username.like('%6')) #以6作为结尾的数据 startswith endswith 以…开头 以…结尾1data = User.query.filter(User.username.endswith('6')) in和not in1data = User.query.filter(~User.age.in_([27,12,1,30,40,50])) 参考: [https://segmentfault.com/a/1190000015240882]参考: [http://docs.jinkan.org/docs/flask/blueprints.html]","link":"/2020/05/19/flask%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"macOS上值得推荐的常用软件","text":"Author: Wee Chou@E-mail: saioukbed@qq.com Note:转载请注明本文出处链接、作者 以下所推荐的 Apps &amp; 服务，都是十分挑剔的本人在使用过许多同类应用后，所筛选出来的自认为真正可以改善生活品质或工作效率的应用 pap.er Pap.er 是一款专门为 macOS 设计的精美壁纸应用，每天更新全球最新高清壁纸；适合喜欢寻找壁纸来改变心情的你。 为什么推荐? 每天更新来自全球的高清(4k,5k)壁纸。 便捷预览壁纸功能：通过缩略图可预览壁纸，能够快速浏览众多壁纸。 强大的即用即设壁纸功能：看到喜欢的壁纸，一键就能设置成为当前桌面壁纸。 壁纸管理便捷：下载过的壁纸，我们贴心的存放到了下载目录，通过应用内直接打开就可以管理。 无广告！无广告！无广告！ =====(づ′▽`)づ ===== IINA IINA 基于 mpv，为最新 Mac 系统而生，支持 Touch Bar、兼容 MPV 脚本、几乎支持所有格式、网络播放，是一款拥有优雅外观的视频播放器。 为什么推荐? 更快和更稳定的解码效果 丰富的设置项 0.25x~16x变速 支持dark mode 免费 开源 无广告 =====(づ′▽`)づ===== Alfred Alfred 这是一款被称之为Mac效率神器的App，有了Alfred 你甚至无需鼠标就可以实现各种操作，包括出发各种文件、网络操作，其UI界面使用方便，而且不是通过命令来实现，是开发者们和键盘刘童鞋们的神器，比之此前类似的软件——Pack和Power来说完全是秒杀的节奏。 应用介绍 这是最基本的了，option+空格激活以后，输入关键字就开始搜索，默认会匹配已经安装的应用软件，我还设置了搜索Safari书签。如果无法匹配，那么会出现搜索google之类的选项，直接触发打开浏览器到搜索引擎搜索。 和Spotlight直接搜索各种类型不同，Alfred要多敲一个空格或者单引号来指示它搜索文件名。实际使用中，我觉得这样更方便和快捷，alfred几乎是秒出结果，而spotlight在迅速反馈结果的同时，有个逐步增加的过程。就对文件的实际搜索效果来说，alfred对文件名的模糊搜索是OK的，但不如Devonthink连文件内容一概通杀的彪悍。当然，DT的彪悍也是在你索引以后的结果，各有专长吧。Spotlight感觉居中，支持文件内容搜索，但仍然不如DT彻底。顺便说一句，DT这几天在促销，可以看这里。 估计键盘流里很多是所谓geek吧，所以alfred支持直接一个“&gt;”后，打开终端执行命令行。 alfred还贴心的支持了和1password的整合。 强力功能需付费!","link":"/2020/05/12/macOSapps/"},{"title":"解读关键字&quot;new&quot;","text":"Author: Wee Chou 在new的过程中到底发生了什么？请先看下面的例子： 1234function Person(){}var person0 = Person() // undefinedvar person1 = new Person() // {} 在平日的开发中，我们对函数的调用无非有两种方法： 直接调用 使用new初始化函数 在上述例子中，我们可以很快理解直接调用返回undefined的原因，因为Person函数没有返回值。但为什么new Person()会返回一个空对象？这就涉及到构造函数的知识了。 那么什么是构造函数？ 我们知道Javascript和其他基于类的语言不同，他是基于对象的，在该语言中没有类的概念（ES6中的“类”也只是语法糖）。那么在Javascript中，我们如何创建对象呢。这就用到了构造函数。 123456function Person(name) { this.name = name;}var person = new Person('wee');console.log(person.name); // wee 这就是一个最简单的构造函数。 现在我们又会疑惑，里面的this是什么？ 我们创建对象，就需要结合this和new。 123function A() { //return this;} 其实，当我们使用new初始化一个函数时，函数内部会隐式返回一个this，如果我们把他想象成一个空对象，就很好解释了。 123456function A() { var obj = new Object(); // 在内存中创建一个空对象 return obj;}var a = new A(); // a指向obj 而赋予this属性和方法，其实等同于赋予这个空对象属性和方法。 12345678function A(name) { var obj = new Object(); obj.name = name; return obj;}var a = new A('wee');console.log(a.name); // wee 而这，就是传统的利用工厂模式创建对象。而利用this，就是构造函数模式创建对象。 那么言归正传，new的过程中到底发生了什么? 12345678910111213141516171819202122232425function A(){}function B(){ this.name = 'wee'; return this; // 显式返回}function _new(func){ var obj = new Object(); var result = func.call(obj); // 将this指向obj // 判断此时A的返回值，若为对象，则返回result，否则返回obj var _result = function() { if (typeof result == 'object') { return result; }else { return obj; } } return _result();}// var a = new A();// 等同于console.log(_new(A)); // {}// var b = new B();// 等同于console.log(_new(B)); // {name:'wee'} 我们可以看到，A中没有返回任何对象，通过_new(A)返回了一个空对象；B中返回了一个对象，则最后的返回结果就为该对象。","link":"/2020/08/07/%E8%A7%A3%E8%AF%BB%E5%85%B3%E9%94%AE%E5%AD%97-new/"},{"title":"原型模式","text":"什么是原型?我们创建的每个函数都有一个 prototype 属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。若按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的对象实例的原型对象。 原型是 Javascript 中的继承的基础，JavaScript 的继承就是基于原型的继承。 使用原型的好处？使用原型的好处是可以让所有对象实例共享属性和方法，而不用多次构建相同的属性或方法，占用多余的内存。 举一个最简单的例子： 123456789function Person() {}Person.prototype.name = \"wee\"; // 在Person原型中设定name属性var person1 = new Person();var person2 = new Person();console.log(person1.name);console.log(person2.name); // 两个同类但不同的实例都能从其原型中访问到name 创建实例对象最好的办法，是结合构造函数模式和原型模式。使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 1234567891011121314function SuperType(name) { this.name = name; this.colors = ['red','purple'];}SuperType.prototype.sayName = function() { console.log(this.name)}function SubType(name, age) { SuperType.call(this, name); // 继承属性,目的是为了让this指向SubType实例对象,使SuperType中的this this.age = age;}subType.prototype = new SuperType() // 继承方法var sub = new SubType('wee','')","link":"/2020/08/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"issues","slug":"issues","link":"/tags/issues/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"}],"categories":[{"name":"front end issues","slug":"front-end-issues","link":"/categories/front-end-issues/"},{"name":"Flask","slug":"Flask","link":"/categories/Flask/"},{"name":"Mac OS","slug":"Mac-OS","link":"/categories/Mac-OS/"},{"name":"models","slug":"Flask/models","link":"/categories/Flask/models/"},{"name":"应用推荐","slug":"Mac-OS/应用推荐","link":"/categories/Mac-OS/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"new关键词","slug":"Javascript/new关键词","link":"/categories/Javascript/new%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"prototype","slug":"Javascript/prototype","link":"/categories/Javascript/prototype/"}]}